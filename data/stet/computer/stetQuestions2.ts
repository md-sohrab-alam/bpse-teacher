// stetQuestions2: Questions 11–20
export const stetQuestions2 = [
  {
    textEn: "Which component of an ideal microcomputer is responsible for temporarily holding data and instructions during processing?",
    textHi: "आदर्श माइक्रोकंप्यूटर में प्रसंस्करण के दौरान डेटा और निर्देशों को अस्थायी रूप से रखने के लिए कौन-सा घटक उत्तरदायी है?",
    optionAEn: "CPU",
    optionAHi: "CPU",
    optionBEn: "ALU",
    optionBHi: "ALU",
    optionCEn: "Memory",
    optionCHi: "मेमोरी",
    optionDEn: "Output devices",
    optionDHi: "आउटपुट उपकरण",
    correct: "C",
    explanationEn: "Primary memory (like RAM) holds instructions/data temporarily during execution.",
    explanationHi: "प्राथमिक मेमोरी (जैसे RAM) निष्पादन के दौरान निर्देश/डेटा अस्थायी रूप से रखती है।"
  },
  {
    textEn: "How is the width of the data bus typically measured in a microcomputer system?",
    textHi: "माइक्रोकंप्यूटर सिस्टम में डेटा बस की चौड़ाई सामान्यतः किसमें मापी जाती है?",
    optionAEn: "Kilobytes (KB)",
    optionAHi: "किलोबाइट (KB)",
    optionBEn: "Megahertz (MHz)",
    optionBHi: "मेगाहर्ट्ज़ (MHz)",
    optionCEn: "Bits",
    optionCHi: "बिट",
    optionDEn: "Address lines",
    optionDHi: "एड्रेस लाइन्स",
    correct: "C",
    explanationEn: "Bus width indicates number of bits transferable in parallel.",
    explanationHi: "बस चौड़ाई पैरेलल में स्थानांतरित होने वाले बिट्स की संख्या दर्शाती है।"
  },
  {
    textEn: "Microcontrollers find application in various fields. What is a typical application of microcontrollers in the automotive industry?",
    textHi: "माइक्रोकंट्रोलर विभिन्न क्षेत्रों में उपयोग होते हैं। ऑटोमोबाइल उद्योग में माइक्रोकंट्रोलर का एक सामान्य अनुप्रयोग क्या है?",
    optionAEn: "Operating systems for computers",
    optionAHi: "कंप्यूटरों के ऑपरेटिंग सिस्टम",
    optionBEn: "Entertainment systems in airplanes",
    optionBHi: "विमानों में एंटरटेनमेंट सिस्टम",
    optionCEn: "Engine control in cars",
    optionCHi: "कारों में इंजन नियंत्रण",
    optionDEn: "Weather forecasting systems",
    optionDHi: "मौसम पूर्वानुमान प्रणाली",
    correct: "C",
    explanationEn: "ECUs use microcontrollers to monitor and control engine parameters.",
    explanationHi: "ECU इंजन के मानकों की निगरानी और नियंत्रण हेतु माइक्रोकंट्रोलर का उपयोग करते हैं।"
  },
  {
    textEn: "Which data structure often results in a time-space tradeoff by using extra memory to speed up operations?",
    textHi: "कौन-सी डाटा संरचना अतिरिक्त मेमोरी का उपयोग करके संचालन को तेज़ करने हेतु समय-स्थान ट्रेड-ऑफ दिखाती है?",
    optionAEn: "Arrays",
    optionAHi: "अरे",
    optionBEn: "Linked lists",
    optionBHi: "लिंक्ड लिस्ट",
    optionCEn: "Hash tables",
    optionCHi: "हैश टेबल",
    optionDEn: "Stacks",
    optionDHi: "स्टैक्स",
    correct: "C",
    explanationEn: "Hash tables trade extra space for average O(1) access.",
    explanationHi: "हैश टेबल अतिरिक्त स्थान के बदले औसत O(1) पहुँच देती हैं।"
  },
  {
    textEn: "Which term refers to the strategy of optimizing an algorithm's use of resources, often by sacrificing one aspect for improvements in another?",
    textHi: "वह कौन-सा पद है जो एल्गोरिद्म के संसाधन-उपयोग को श्रेष्ठ बनाने की रणनीति को दर्शाता है, जिसमें एक पहलू की कीमत पर दूसरे में सुधार किया जाता है?",
    optionAEn: "Greedy algorithm",
    optionAHi: "ग्रीडी एल्गोरिद्म",
    optionBEn: "Divide and conquer",
    optionBHi: "डिवाइड एंड कॉन्कर",
    optionCEn: "Dynamic programming",
    optionCHi: "डायनेमिक प्रोग्रामिंग",
    optionDEn: "Tradeoff",
    optionDHi: "ट्रेड-ऑफ़",
    correct: "D",
    explanationEn: "Tradeoff means balancing competing resource goals (time vs space).",
    explanationHi: "ट्रेड-ऑफ़ का अर्थ है प्रतिस्पर्धी लक्ष्यों (समय बनाम स्थान) में संतुलन।"
  },
  {
    textEn: "Conditional asymptotic notation allows nuanced analysis under specific conditions. It is most useful when:",
    textHi: "शर्तीय एसिम्प्टोटिक संकेतन विशेष स्थितियों में सूक्ष्म विश्लेषण की अनुमति देता है। यह सबसे उपयोगी कब होता है?",
    optionAEn: "Analyzing algorithms with constant time complexity",
    optionAHi: "स्थिर समय जटिलता वाले एल्गोरिद्म का विश्लेषण",
    optionBEn: "The input size is fixed",
    optionBHi: "इनपुट आकार स्थिर हो",
    optionCEn: "The input data is random",
    optionCHi: "इनपुट डेटा यादृच्छिक हो",
    optionDEn: "Algorithm behavior varies by input characteristics",
    optionDHi: "एल्गोरिद्म का व्यवहार इनपुट के गुणों पर निर्भर हो",
    correct: "D",
    explanationEn: "It captures behavior only when certain input properties hold.",
    explanationHi: "यह केवल तब व्यवहार को दर्शाता है जब कुछ इनपुट गुण सत्य हों।"
  },
  {
    textEn: "If an algorithm's behavior is bounded by 'o(f(n)) if g(n)', what notation remains when the condition is removed?",
    textHi: "यदि किसी एल्गोरिद्म का व्यवहार 'o(f(n)) यदि g(n)' से बंधित है, तो शर्त हटाने पर कौन-सा संकेतन शेष रहता है?",
    optionAEn: "o(f(n))",
    optionAHi: "o(f(n))",
    optionBEn: "o(g(n))",
    optionBHi: "o(g(n))",
    optionCEn: "o(f(n) + g(n))",
    optionCHi: "o(f(n) + g(n))",
    optionDEn: "o(f(n) * g(n))",
    optionDHi: "o(f(n) * g(n))",
    correct: "A",
    explanationEn: "Removing the condition leaves the original little-o bound.",
    explanationHi: "शर्त हटाने पर मूल लिटिल-o सीमा ही रहती है।"
  },
  {
    textEn: "The recurrence T(n) = T(n/2) + 1 represents the time complexity of which paradigm?",
    textHi: "पुनरावृत्ति T(n) = T(n/2) + 1 किस एल्गोरिद्मिक प्रतिमान की समय जटिलता दिखाती है?",
    optionAEn: "Divide and Conquer",
    optionAHi: "डिवाइड एंड कॉन्कर",
    optionBEn: "Greedy Algorithms",
    optionBHi: "ग्रीडी एल्गोरिद्म",
    optionCEn: "Dynamic Programming",
    optionCHi: "डायनेमिक प्रोग्रामिंग",
    optionDEn: "Brute Force",
    optionDHi: "ब्रूट फोर्स",
    correct: "A",
    explanationEn: "The problem size halves each step; depth is O(log n).",
    explanationHi: "प्रत्येक चरण में समस्या का आकार आधा होता है; गहराई O(log n) है।"
  },
  {
    textEn: "Divide and Conquer solves problems by:",
    textHi: "डिवाइड एंड कॉन्कर समस्याओं को कैसे हल करता है?",
    optionAEn: "Iteratively solving subproblems",
    optionAHi: "उपसमस्याओं को आवर्तक रूप से हल करके",
    optionBEn: "Recursively solving subproblems",
    optionBHi: "उपसमस्याओं को पुनरावर्ती रूप से हल करके",
    optionCEn: "Using heuristics",
    optionCHi: "ह्यूरिस्टिक्स का उपयोग करके",
    optionDEn: "Greedily combining solutions",
    optionDHi: "लालची तरीके से समाधान जोड़कर",
    correct: "B",
    explanationEn: "Problems are split into subproblems solved recursively and combined.",
    explanationHi: "समस्या को उपसमस्याओं में बाँटकर पुनरावृत्त रूप से हल कर संयोजित किया जाता है।"
  },
  {
    textEn: "A threaded binary tree is a binary tree in which:",
    textHi: "थ्रेडेड बाइनरी ट्री वह बाइनरी ट्री है जिसमें:",
    optionAEn: "Each node has two children",
    optionAHi: "प्रत्येक नोड के दो बच्चे हों",
    optionBEn: "Each node has at most one child",
    optionBHi: "प्रत्येक नोड के अधिकतम एक बच्चा",
    optionCEn: "Each node is connected to its parent",
    optionCHi: "प्रत्येक नोड अपने पैरेंट से जुड़ा हो",
    optionDEn: "Each node has a thread to predecessor or successor",
    optionDHi: "प्रत्येक नोड में पूर्ववर्ती/उत्तरोत्तर के लिए थ्रेड हो",
    correct: "D",
    explanationEn: "Threads link null pointers to inorder predecessor/successor.",
    explanationHi: "नल पॉइंटर्स को इन-ऑर्डर पूर्ववर्ती/उत्तरोत्तर से थ्रेड द्वारा जोड़ा जाता है।"
  }
];
